
==================== FINAL INTERFACE ====================
2019-01-01 23:22:33.418021 UTC

interface perfect-numbers-1.1.0.4-ELx9s8LuJeBHVMGladIPOZ:PerfectNumbers 8043
  interface hash: b67e5c783db8f5bed334aa877bba339f
  ABI hash: 0fe47e6c846acc7dfab59f8b9cd56d37
  export-list hash: 73b16342af40a6a5eba9d19277921d8e
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 8f52f5e5828eb5661f405d8d9ca450ec
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  PerfectNumbers.classify
  PerfectNumbers.Classification{PerfectNumbers.Abundant PerfectNumbers.Deficient PerfectNumbers.Perfect}
module dependencies:
package dependencies: base-4.11.1.0* ghc-prim-0.5.2.0
                      integer-gmp-1.0.2.0
orphans: base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity base-4.11.1.0:Data.Monoid
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:GHC.Generics
                         base-4.11.1.0:GHC.IO.Exception
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.List 1e4357702d8d00cded0703bd293e50e8
import  -/  base-4.11.1.0:GHC.Num 8e54b26dce4495382dc4b50cf36ab754
import  -/  base-4.11.1.0:GHC.Real b4beb0389ba1ad5d9640aae67848c5d3
import  -/  base-4.11.1.0:GHC.Show 73be67392447c974f19c3befd83c46c0
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
12609906d028e6a5acfa578d6857b058
  $fEqClassification :: GHC.Classes.Eq PerfectNumbers.Classification
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ PerfectNumbers.Classification
                  PerfectNumbers.$fEqClassification_$c==
                  PerfectNumbers.$fEqClassification_$c/= -}
12609906d028e6a5acfa578d6857b058
  $fEqClassification_$c/= ::
    PerfectNumbers.Classification
    -> PerfectNumbers.Classification -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: PerfectNumbers.Classification)
                   (y :: PerfectNumbers.Classification) ->
                 case x of wild {
                   PerfectNumbers.Deficient
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True
                        PerfectNumbers.Deficient -> GHC.Types.False }
                   PerfectNumbers.Perfect
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True
                        PerfectNumbers.Perfect -> GHC.Types.False }
                   PerfectNumbers.Abundant
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True
                        PerfectNumbers.Abundant -> GHC.Types.False } }) -}
12609906d028e6a5acfa578d6857b058
  $fEqClassification_$c== ::
    PerfectNumbers.Classification
    -> PerfectNumbers.Classification -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: PerfectNumbers.Classification)
                   (ds1 :: PerfectNumbers.Classification) ->
                 case ds of wild {
                   PerfectNumbers.Deficient
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PerfectNumbers.Deficient -> GHC.Types.True }
                   PerfectNumbers.Perfect
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PerfectNumbers.Perfect -> GHC.Types.True }
                   PerfectNumbers.Abundant
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PerfectNumbers.Abundant -> GHC.Types.True } }) -}
12609906d028e6a5acfa578d6857b058
  $fShowClassification :: GHC.Show.Show PerfectNumbers.Classification
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ PerfectNumbers.Classification
                  PerfectNumbers.$fShowClassification_$cshowsPrec
                  PerfectNumbers.$fShowClassification_$cshow
                  PerfectNumbers.$fShowClassification_$cshowList -}
c0628c529f2fd7bb12338581a65d635f
  $fShowClassification1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PerfectNumbers.$fShowClassification2) -}
431273fe91fd15c3a48a0ada43f1cde8
  $fShowClassification2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Abundant"#) -}
3dcb56560d431059354ea45ac9bf459b
  $fShowClassification3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PerfectNumbers.$fShowClassification4) -}
5eb6c465766aad81ad20294d1bddeb9a
  $fShowClassification4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Perfect"#) -}
bcaff88eae39068f3947c2daeeafa7f7
  $fShowClassification5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PerfectNumbers.$fShowClassification6) -}
820419167135eced4bdb44d41290c4e6
  $fShowClassification6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Deficient"#) -}
12609906d028e6a5acfa578d6857b058
  $fShowClassification_$cshow ::
    PerfectNumbers.Classification -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: PerfectNumbers.Classification) ->
                 case x of wild {
                   PerfectNumbers.Deficient -> PerfectNumbers.$fShowClassification5
                   PerfectNumbers.Perfect -> PerfectNumbers.$fShowClassification3
                   PerfectNumbers.Abundant
                   -> PerfectNumbers.$fShowClassification1 }) -}
12609906d028e6a5acfa578d6857b058
  $fShowClassification_$cshowList ::
    [PerfectNumbers.Classification] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [PerfectNumbers.Classification])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ PerfectNumbers.Classification
                   PerfectNumbers.$w$cshowsPrec
                   ls
                   s) -}
12609906d028e6a5acfa578d6857b058
  $fShowClassification_$cshowsPrec ::
    GHC.Types.Int -> PerfectNumbers.Classification -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: [0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: PerfectNumbers.Classification)
                   (w2 :: GHC.Base.String) ->
                 PerfectNumbers.$w$cshowsPrec w1 w2) -}
19421692af43748155a114c90e5e5c10
  $tc'Abundant :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13324776707274248676##
                   14960002965057986787##
                   PerfectNumbers.$trModule
                   PerfectNumbers.$tc'Abundant2
                   0#
                   PerfectNumbers.$tc'Abundant1) -}
1710b5b04621433c92b84f36936ddf61
  $tc'Abundant1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
86cb29b9766a1bf895a04165d25e723c
  $tc'Abundant2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS PerfectNumbers.$tc'Abundant3) -}
24c5e66c54038f272710b9e403befd81
  $tc'Abundant3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Abundant"#) -}
e4e25e1026b5e1e12f68582d849a9d34
  $tc'Deficient :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3331144455172797151##
                   13511413368677827151##
                   PerfectNumbers.$trModule
                   PerfectNumbers.$tc'Deficient1
                   0#
                   PerfectNumbers.$tc'Abundant1) -}
961b1405818d4e952e469e309a2b925c
  $tc'Deficient1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS PerfectNumbers.$tc'Deficient2) -}
6ba0218efc504434476ad6d22e5d4882
  $tc'Deficient2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Deficient"#) -}
db6b002862254646bc516d2c815acc26
  $tc'Perfect :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9579294802507887958##
                   12992666428985922190##
                   PerfectNumbers.$trModule
                   PerfectNumbers.$tc'Perfect1
                   0#
                   PerfectNumbers.$tc'Abundant1) -}
97ecd3cb202e006041970fc34c4f3ae9
  $tc'Perfect1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS PerfectNumbers.$tc'Perfect2) -}
a497a93118707f6514cad3360ad964b9
  $tc'Perfect2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Perfect"#) -}
835065211212f25cefd7dcb4a9ff3dc7
  $tcClassification :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16346897393896777503##
                   13100367381577432203##
                   PerfectNumbers.$trModule
                   PerfectNumbers.$tcClassification1
                   0#
                   GHC.Types.krep$*) -}
aa1f45adb766b68e28f73c52742f9f42
  $tcClassification1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS PerfectNumbers.$tcClassification2) -}
9473bb966651cbacfd7ad21a9a3ec6d1
  $tcClassification2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Classification"#) -}
6e8c4103b199ead74c94f451a3075d53
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   PerfectNumbers.$trModule3
                   PerfectNumbers.$trModule1) -}
c0a160d0e96a46798f986ad385a30652
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS PerfectNumbers.$trModule2) -}
f534af4677de0947121584e2742b4799
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("PerfectNumbers"#) -}
1c212267cbc0cc8cf75043dad54ad6ec
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS PerfectNumbers.$trModule4) -}
e63db8b99bf9fbdff10153266ba65962
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("perfect-numbers-1.1.0.4-ELx9s8LuJeBHVMGladIPOZ"#) -}
12609906d028e6a5acfa578d6857b058
  $w$cshowsPrec ::
    PerfectNumbers.Classification -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: PerfectNumbers.Classification)
                   (w1 :: GHC.Base.String) ->
                 case w of wild {
                   PerfectNumbers.Deficient
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PerfectNumbers.$fShowClassification5
                        w1
                   PerfectNumbers.Perfect
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PerfectNumbers.$fShowClassification3
                        w1
                   PerfectNumbers.Abundant
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PerfectNumbers.$fShowClassification1
                        w1 }) -}
d2d0d39674421eef6111c6f9f1e1b7ca
  $wclassify ::
    GHC.Prim.Int# -> GHC.Base.Maybe PerfectNumbers.Classification
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case GHC.Prim.<# ww 1# of lwild {
                   DEFAULT
                   -> let {
                        y :: GHC.Prim.Int# = GHC.Prim.-# ww 1#
                      } in
                      case GHC.Prim.># 1# y of lwild1 {
                        DEFAULT
                        -> let {
                             $j :: GHC.Prim.Int# -> GHC.Base.Maybe PerfectNumbers.Classification
                               <join 1> {- Arity: 1, Strictness: <S,U> -}
                             = \ (ww1 :: GHC.Prim.Int#)[OneShot] ->
                               case GHC.Prim.==# ww1 ww of lwild2 {
                                 DEFAULT
                                 -> case GHC.Prim.># ww1 ww of lwild3 {
                                      DEFAULT -> PerfectNumbers.classify3
                                      1# -> PerfectNumbers.classify2 }
                                 1# -> PerfectNumbers.classify1 }
                           } in
                           letrec {
                             $wgo :: GHC.Prim.Int#
                                     -> GHC.Prim.Int#
                                     -> GHC.Base.Maybe PerfectNumbers.Classification
                               <join 2> {- Arity: 2, Strictness: <S,1*U><S,U>, Inline: [0] -}
                             = \ (w :: GHC.Prim.Int#) (ww1 :: GHC.Prim.Int#) ->
                               case w of wild1 {
                                 DEFAULT
                                 -> case GHC.Prim.remInt# ww wild1 of wild3 {
                                      DEFAULT
                                      -> case GHC.Prim.==# wild1 y of lwild2 {
                                           DEFAULT -> $wgo (GHC.Prim.+# wild1 1#) ww1 1# -> $j ww1 }
                                      0#
                                      -> case GHC.Prim.==# wild1 y of lwild2 {
                                           DEFAULT
                                           -> $wgo (GHC.Prim.+# wild1 1#) (GHC.Prim.+# ww1 wild1)
                                           1# -> $j (GHC.Prim.+# ww1 wild1) } }
                                 -1#
                                 -> case y of wild {
                                      DEFAULT -> $wgo 0# (GHC.Prim.+# ww1 -1#)
                                      -1# -> $j (GHC.Prim.+# ww1 -1#) }
                                 0#
                                 -> case GHC.Real.divZeroError
                                    ret_ty (GHC.Base.Maybe PerfectNumbers.Classification)
                                    of {} }
                           } in
                           $wgo 1# 0#
                        1#
                        -> case ww of wild {
                             DEFAULT
                             -> case GHC.Prim.># 0# wild of lwild2 {
                                  DEFAULT -> PerfectNumbers.classify3
                                  1# -> PerfectNumbers.classify2 }
                             0# -> PerfectNumbers.classify1 } }
                   1# -> GHC.Base.Nothing @ PerfectNumbers.Classification }) -}
12609906d028e6a5acfa578d6857b058
  data Classification = Deficient | Perfect | Abundant
2551f9556bbf8c8e1361b6e349f6f441
  classify ::
    GHC.Types.Int -> GHC.Base.Maybe PerfectNumbers.Classification
  {- Arity: 1, Strictness: <S(S),1*U(U)>, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PerfectNumbers.$wclassify ww1 }) -}
cb7b94c554ae8ee1d48ffba970c4b478
  classify1 :: GHC.Base.Maybe PerfectNumbers.Classification
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Base.Just
                   @ PerfectNumbers.Classification
                   PerfectNumbers.Perfect) -}
91412528c8266379cf50db5c33e99ab8
  classify2 :: GHC.Base.Maybe PerfectNumbers.Classification
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Base.Just
                   @ PerfectNumbers.Classification
                   PerfectNumbers.Abundant) -}
ba637311c07535318b78f1b481aaaec1
  classify3 :: GHC.Base.Maybe PerfectNumbers.Classification
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Base.Just
                   @ PerfectNumbers.Classification
                   PerfectNumbers.Deficient) -}
instance [safe] GHC.Classes.Eq [PerfectNumbers.Classification]
  = PerfectNumbers.$fEqClassification
instance [safe] GHC.Show.Show [PerfectNumbers.Classification]
  = PerfectNumbers.$fShowClassification
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

